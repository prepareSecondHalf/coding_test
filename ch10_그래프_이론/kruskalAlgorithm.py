'''
[신장 트리] 하나의 그래프가 있을 때 모든 노드를 포함하면서 (서로 연결되면서) 사이클이 존재하지 않는 부분 그래프
신장 트리(spanning tree)
spanning : 
1. Noun (어떤 일이 지속되는) 기간[시간] (→lifespan)
2. Noun (포괄하는) 폭[범위], 다양성
3. Verb (얼마의 기간에) 걸치다[걸쳐 이어지다]
4. Verb (넓은 범위많은 것에[을]) 걸치다[포괄하다]

신장 4 伸張
noun 세력이나 권리 따위가 늘어남. 또는 늘어나게 함.

깊이 우선 탐색이나 너비 우선 탐색을 하게 되면 생기는 트리엣지로 이루어진 사이클을 갖지 않는  최소 부분 그래프가 생기는데 이 부분 그래프를 그래프 G에 대한 신장 트리라고 한다. 
- 연결 그래프 G = (V, E)에 대해서 깊이 우선 탐색이나 너비 우선 탐색을 하게 되면 정점들을 방문하면서 지나는 엣지들을 보면 트리 형태의 모양을 띄게 된다. 
- 이러한 그래프를 탐색하면서 지나게 되는 엣지들의 집합을 트리 엣지(tree edge)
- 트리 엣지를 제외한 나머지 엣지들을 비트리 엣지(nontree edge)
- 깊이 우선 탐색으로 만들어진 신장 트리(depth first spanning tree)와 
- 너비 우선 탐색으로 만들어진 신장 트리(breath first spanning tree)로 나누어 진다. 

[최소 신장 트리 알고리즘] 최소한의 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘
- 각 엣지에 가중치가 부여된 무방향 그래프에서 만들어지는 신장 트리중 가중치의 합이 가장 작은 신장 트리를 특별히 최소 비용 신장 트리(minimum cost spanning tree)라고 한다. 
- 이는 통신 네트워크나 빠른 길찾기등의 문제에서 많이 활용되고 있다.

* [가중치 from chatGPT]
- 프로그래밍에서 "가중치"는 일반적으로 머신 러닝 및 신경망과 관련된 개념으로 사용됩니다. 가중치는 모델의 학습 과정에서 조정되는 매개변수로, 입력 데이터와 연관된 특정한 중요도나 영향력을 나타냅니다.
- 가중치는 각각의 입력 특성에 곱해지는 값으로, 모델이 입력 데이터를 처리하고 예측을 수행하는 방식을 제어합니다. 가중치는 모델의 학습 과정에서 최적화되며, 학습 알고리즘이 입력과 출력 사이의 관계를 학습하면서 가중치를 조정합니다.
- 예를 들어, 선형 회귀 모델에서는 입력 특성과 가중치의 곱의 합이 예측값을 생성하는 데 사용됩니다. 각 입력 특성은 해당하는 가중치에 따라 예측에 더 큰 또는 작은 영향을 미칩니다. 학습 과정에서 모델은 입력과 실제 출력 사이의 차이(오차)를 최소화하기 위해 가중치를 조정합니다.
- 신경망에서 가중치는 각각의 뉴런 사이의 연결 강도를 나타내는 역할을 합니다. 각 뉴런은 입력 신호에 가중치를 곱하고, 이를 활성화 함수를 통과시켜 다음 뉴런으로 전달합니다. 학습 과정에서 가중치는 오차 역전파(backpropagation) 알고리즘을 사용하여 조정되며, 이를 통해 모델은 입력과 출력 사이의 복잡한 관계를 학습할 수 있습니다.
- 딥 러닝에서는 가중치가 여러 층에 걸쳐 연결되는 신경망 구조를 가지고 있으며, 이 가중치들을 최적화하는 것이 학습의 주요 목표입니다. 가중치의 최적화는 손실 함수를 최소화하거나 정확도를 최대화하는 방향으로 이루어집니다.
- 따라서, 프로그래밍에서 가중치는 모델의 학습 및 예측 과정에서 중요한 역할을 하는 매개변수로 사용됩니다.

[크루스칼 알고리즘] 대표적인 최소 신장 트리 알고리즘
- 가장 적은 비용으로 모든 노드를 연결할 수 있으며, 그리디 알고리즘으로 분류
- 모든 간선에 대해 정렬을 수행한 뒤에, 가장 거리가 짧은 간선부터 집합에 포함시키면 된다. (다만, 사이클을 발생시킬 수 있는 간선의 경우, 집합에 포함시키지 않는다.)

1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인한다.
2-1. 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
2-2. 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
3. 모든 간선에 대하여 2번의 과정을 반복한다.

'''
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

v, e = map(int, input().split())
parent = [0] * (v + 1)

edges = []
result = 0

for i in range(1, v + 1):
    parent[i] = i

# 모든 간선에 대한 정보를 입력받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    edges.append((cost, a, b)) # 비용순 정렬

edges.sort()

# 간선을 하나씩 확인
for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)