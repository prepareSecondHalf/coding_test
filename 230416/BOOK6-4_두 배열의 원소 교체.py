# 동빈이는 두 개의 배열 A와 B를 가지고 있다. 
# 두 배열은 N개의 원소로 구성되어 있으며 배열의 원소는 모두 자연수이다.
# 동빈이는 최대 K번의 바꿔치기 연산을 수행 가능한데, 이는 A의 원소와 B의 원소를 하나씩 골라 서로 교환하는 것이다.
# 최종 목표는 A의 모든 원소의 합이 최대가 되는 것이다.

# N, K, A, B가 주어질 때, 최대 K번의 연산을 통해 만들 수 있는 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하시오.

# 입력
# 첫 번째 줄에 N, K가 공백으로 구분되어 입력된다. (1 <= N <= 100,000) (0 <= K ,+ N)
# 두 번째 줄에 배열 A의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작은 자연수이다.
# 세 번째 줄에 배열 B의 원소들이 공백으로 구분되어 입력된다. 모든 원소는 10,000,000보다 작은 자연수이다.

# 출력
# 최대 K번의 바꿔치기 연산을 수행한 후 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력한다.

import sys
n, k = map(int, sys.stdin.readline().split())
a = list(map(int, sys.stdin.readline().split()))
b = list(map(int, sys.stdin.readline().split()))

# 풀이
# a를 최대로 만들어야 하므로
# a의 최솟값이 b의 최댓값보다 작으면 바꿔치기를 수행하면 된다.
# a를 오름차순, b를 내림차순으로 정렬하여 index를 맞추고
# index가 k가 될 때까지 같은 index 상에서 a가 b보다 작다면 바꿔치기를 수행하면 된다.
# 근데 문제는 결국 최댓값을 구하는 것이므로 굳이 a, b를 바꿀 필요 없이
# 둘 중 더 큰 수를 더하면 된다.
a.sort()
b.sort(reverse=True)

answer = 0
idx = 0
while idx < k:
    answer += max([a[idx], b[idx]])
    idx += 1
answer += sum(a[k:])

print(answer)