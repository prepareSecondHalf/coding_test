# 어떤 나라에는 N개의 도시가 있다. 각 도시는 보내고자 하는 메시지가 있는 경우 다른 도시로 전보를 보낸다.
# X에서 Y로 보내고자 한다면 통로가 설치되어 있어야 한다.
# 통로는 단방향이며 일정 시간이 소요된다.
# 어느 날 C 도시에서 위급 상황이 발생해 최대한 많은 도시로 메시지를 보내려 한다.
# 메시지는 C에서 출발해 최대한 멀리 퍼져 나갈 것이다.
# 각 도시명과 통로에 대한 정보가 주어졌을 때, C에서 보낸 메시지를 받게 되는 도시의 개수는 몇 개이고 각각 걸리는 시간이 얼마인지 계산하시오

# 입력
# 첫째 줄에 도시의 개수 N, 통로의 개수 M, 메시지를 보내고자 하는 C가 주어진다. (1 <= N <= 30000) (1 <= M <= 200000) (1 <= C <= N)
# 둘째 줄부터 M+1번째 줄에 걸쳐 통로에 대한 정보 X, Y, Z가 주어진다. 이는 X에서 Y로 이어지는 통로가 있으며 Z만큼 시간이 걸린다는 의미이다.
# (1 <= X, Y, <= N) (1 <= Z <= 1000)

# 출력
# 첫째 줄에 C에서 보낸 메시지를 받는 도시의 총 개수와 총 시간을 공백으로 구분하여 출력한다.

import sys
n, m, c = map(int, sys.stdin.readline().split())

# 풀이
# 1. 각 노드와 연결된 노드의 정보를 초기화
graph = [[] for _ in range(n+1)]
INF = float('inf')
# 2. 최단 거리 테이블 초기화(무한)
distance = [INF] * (n+1)
# 3. 간선 정보 입력 (x에서 y로 갈 때 걸리는 시간 z)
for _ in range(m):
    x, y, z = map(int, sys.stdin.readline().split())
    graph[x].append((y, z))
print(*graph, sep='\n')
# 여기까지 작성하면 graph는
# (2, 4)    (3, 2)
# ()        ()
# ()        ()
# 위와 같이 초기화된다. 1에서 2, 1에서 3으로 가는 케이스밖에 없기 때문


# TEST CASE
# 3 2 1
# 1 2 4
# 1 3 2