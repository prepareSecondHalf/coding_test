# 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.           O   O       O       O
# 예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

# 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.
# 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

# 첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

import sys
n = int(sys.stdin.readline())
a = list(map(int, sys.stdin.readline().split()))

# 풀이: 증가하는 부분 수열을 dp table에 저장
# i번째 수를 체크할 때, dp[i-1]과 i번째 수 중 큰 수를 dp에 저장한다.
# 즉, 수열 10, 20, 10, 30, 20, 50이 주어졌을 때, dp는
# 10
# 10, 20
# 10, 20, 20
# 10, 20, 20, 30
# 10, 20, 20, 30, 30
# 10, 20, 20, 30, 30, 50
# 위와 같이 중복 값이 있는 list로 저장된다.
# 길이를 구하는 것이므로 최종적으로 작성한 dp table의 중복을 제거하고 길이를 구하면 된다.
dp = [0] * n
dp[0] = a[0]
dp[1] = max(a[0], a[1])
print('initial dp', dp)
for i in range(2, n):
    # 라고 생각했는데 조건 없이 그냥 실행하면 10, 50, 20, 30, 40 같은 케이스에 대응이 안 된다.
    if a[i] > dp[i-2]:
        # 따라서, a[i]가 dp[i-2]보다 클 때 dp[i-1]과 대소비교를 해야 한다.
        # 이 경우에도 a[i]가 dp[i-1]보다 크거나 같은 경우와 작은 경우가 있다.
        # a[i]가 dp[i-1]보다 작다면, dp[i-1]도 a[i]로 바뀌어야 함 (?)
        dp[i-1] = a[i]
        dp[i] = a[i]
        # dp[i] = max(dp[i-1], a[i])
    else:
        # 작거나 같다면 중복제거 예정이므로 dp[i]는 그냥 dp[i-1]과 같으면 된다.
        dp[i] = dp[i-1]
print(dp)
# print(len(set(dp)))
